/**
 * Code generated by protoc-gen-twirp_js v5.0.0, DO NOT EDIT.
 * source: service.proto
 * This is the browser version of this code
 * It has a dependency on `fetch`, so polyfill if your browser does not support it.
 * For Example: https://github.com/github/fetch
 */
const pb = require("./service_pb.js");

// Simple Twirp RPC Client implementation for the browser
const newClient = (baseurl, serviceName, useJSON) => {
    const endpoint = baseurl + "/twirp/"+serviceName + "/";
	const mimeType = useJSON ? "application/json" : "application/protobuf";
	const serialize = useJSON
		? msg => JSON.stringify(msg.toObject())
		: msg => msg.serializeBinary();
	return (method, requestMsg, responseType) => {
		const deserialize = useJSON
			? res => res.json()
			: res => res.arrayBuffer().then(buf => responseType.deserializeBinary(new Uint8Array(buf)).toObject());
		const opts = {
			method: "POST",
			body: serialize(requestMsg),
			redirect: "manual",
			headers: {
				"Content-Type": mimeType,
				"Accept": mimeType,
				"Twirp-Version": "v5.0.0"
            }
        };
        return fetch(endpoint + method, opts).then(res => {
            // 200 is the only valid response
            if (res.status !== 200) {
                return resToError(res);
            }
            return deserialize(res);
        });
    };
}

const twirpError = ({ code, msg, meta = {} } = {}) => Object.assign(
    new Error(msg),
    { meta, code }
);

// Twirp Error implementation
function resToError(res) {
	const intermediateError = meta => twirpError({
		code: "internal",
		msg: "Error from intermediary with HTTP status code " +
			res.status + " " + res.statusText,
		meta: meta
	});
    return res.json()
        .then(obj => {
            if (!obj.code || !obj.msg) {
				throw intermediateError(obj);
            }
            throw twirpError(obj);
        },
        _ => { // error decoding JSON error
            throw intermediateError({});
        });
}

// build a message from data
function buildMessage(type, data) {
	const msg = new type();
	Object.keys(data).forEach(key => {
		const setter = "set" + key[0].toUpperCase() + key.slice(1);
		if (setter in msg) {
			msg[setter](data[key]);
		}
	});
	return msg;
}


/**
 * A Haberdasher makes hats for clients.
 */
exports.createHaberdasherClient = function(baseurl, useJSON) {
    const rpc = newClient(baseurl, "twitch.twirp.example.Haberdasher", useJSON);
    return {
        /**
         * MakeHat produces a hat of mysterious, randomly-selected color!
         */
        makeHat: data => rpc("MakeHat", buildMessage(pb.Size, data), pb.Hat)
    }
}

