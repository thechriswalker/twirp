/**
 * Code generated by protoc-gen-twirp_js v5.0.0, DO NOT EDIT.
 * source: clientcompat.proto
 * This is the node.js version of this code
 * It has a dependency on `node-fetch` module available from npm
 */
const pb = require("./clientcompat_pb.js");
const fetch = require("node-fetch")

// Simple Twirp RPC Client implementation for the browser
const newClient = (baseurl, serviceName, useJSON) => {
    const endpoint = baseurl + "/twirp/"+serviceName + "/";
	const mimeType = useJSON ? "application/json" : "application/protobuf";
	const serialize = useJSON
		? msg => JSON.stringify(msg.toObject())
		: msg => Buffer.from(msg.serializeBinary());
	return (method, requestMsg, responseType) => {
		const deserialize = useJSON
			? res => res.json()
			: res => res.buffer().then(buf => responseType.deserializeBinary(new Uint8Array(buf)).toObject());
		const opts = {
			method: "POST",
			body: serialize(requestMsg),
			redirect: "manual",
			headers: {
				"Content-Type": mimeType,
				"Accept": mimeType,
				"Twirp-Version": "v5.0.0"
            }
        };
        return fetch(endpoint + method, opts).then(res => {
            // 200 is the only valid response
            if (res.status !== 200) {
                return resToError(res);
            }
            return deserialize(res);
        });
    };
}

const twirpError = ({ code, msg, meta = {} } = {}) => Object.assign(
    new Error(msg),
    { meta, code }
);

// Twirp Error implementation
function resToError(res) {
	const intermediateError = meta => twirpError({
		code: "internal",
		msg: "Error from intermediary with HTTP status code " +
			res.status + " " + res.statusText,
		meta: meta
	});
    return res.json()
        .then(obj => {
            if (!obj.code || !obj.msg) {
				throw intermediateError(obj);
            }
            throw twirpError(obj);
        },
        _ => { // error decoding JSON error
            throw intermediateError({});
        });
}

// build a message from data
function buildMessage(type, data) {
	const msg = new type();
	Object.keys(data).forEach(key => {
		const setter = "set" + key[0].toUpperCase() + key.slice(1);
		if (setter in msg) {
			msg[setter](data[key]);
		}
	});
	return msg;
}


/**
 * Creates a new CompatServiceClient
 */
exports.createCompatServiceClient = function(baseurl, useJSON) {
    const rpc = newClient(baseurl, "twirp.clientcompat.CompatService", useJSON);
    return {
        method: data => rpc("Method", buildMessage(pb.Req, data), pb.Resp),
        noopMethod: data => rpc("NoopMethod", buildMessage(pb.Empty, data), pb.Empty)
    }
}

