package main

import (
	"bytes"
	"flag"
	"fmt"
	"os"
	"path"
	"strconv"
	"strings"

	"github.com/golang/protobuf/proto"
	"github.com/golang/protobuf/protoc-gen-go/descriptor"
	plugin "github.com/golang/protobuf/protoc-gen-go/plugin"
	"github.com/twitchtv/twirp/internal/gen"
	"github.com/twitchtv/twirp/internal/gen/stringutils"
	"github.com/twitchtv/twirp/internal/gen/typemap"
)

func main() {
	versionFlag := flag.Bool("version", false, "print version and exit")
	flag.Parse()
	if *versionFlag {
		fmt.Println(gen.Version)
		os.Exit(0)
	}

	g := newGenerator()
	gen.Main(g)
}

func newGenerator() *generator {
	return &generator{output: new(bytes.Buffer)}
}

type generator struct {
	reg    *typemap.Registry
	output *bytes.Buffer
}

func (g *generator) Generate(in *plugin.CodeGeneratorRequest) *plugin.CodeGeneratorResponse {
	genFiles := gen.FilesToGenerate(in)
	g.reg = typemap.New(in.ProtoFile)

	resp := new(plugin.CodeGeneratorResponse)
	for _, f := range genFiles {
		respFile := g.generateFile(f, true)
		if respFile != nil {
			resp.File = append(resp.File, respFile)
		}
		respFile = g.generateFile(f, false)
		if respFile != nil {
			resp.File = append(resp.File, respFile)
		}
	}

	return resp
}

// this could be in a different module.
const baseClientJSPrefix = `// Simple Twirp RPC Client implementation for the browser
const newClient = (baseurl, serviceName, useJSON) => {
    const endpoint = baseurl + "/twirp/"+serviceName + "/";
	const mimeType = useJSON ? "application/json" : "application/protobuf";
	const serialize = useJSON
		? msg => JSON.stringify(msg.toObject())
		: `

const nodeJSSerialize = `msg => Buffer.from(msg.serializeBinary());`
const nodeJSDeserialize = `res => res.buffer().then(buf => responseType.deserializeBinary(new Uint8Array(buf)).toObject());`
const browserSerialize = `msg => msg.serializeBinary();`
const browserDeserialize = `res => res.arrayBuffer().then(buf => responseType.deserializeBinary(new Uint8Array(buf)).toObject());`
const baseClientJSMidpoint = `
	return (method, requestMsg, responseType) => {
		const deserialize = useJSON
			? res => res.json()
			: `
const baseClientJSPenultimate = `
		const opts = {
			method: "POST",
			body: serialize(requestMsg),
			redirect: "manual",
			headers: {
				"Content-Type": mimeType,
				"Accept": mimeType,
				"Twirp-Version": `

const baseClientJSPostfix = `
            }
        };
        return fetch(endpoint + method, opts).then(res => {
            // 200 is the only valid response
            if (res.status !== 200) {
                return resToError(res);
            }
            return deserialize(res);
        });
    };
}

const twirpError = ({ code, msg, meta = {} } = {}) => Object.assign(
    new Error(msg),
    { meta, code }
);

// Twirp Error implementation
function resToError(res) {
	const intermediateError = meta => twirpError({
		code: "internal",
		msg: "Error from intermediary with HTTP status code " +
			res.status + " " + res.statusText,
		meta: meta
	});
    return res.json()
        .then(obj => {
            if (!obj.code || !obj.msg) {
				throw intermediateError(obj);
            }
            throw twirpError(obj);
        },
        _ => { // error decoding JSON error
            throw intermediateError({});
        });
}

// build a message from data
function buildMessage(type, data) {
	const msg = new type();
	Object.keys(data).forEach(key => {
		const setter = "set" + key[0].toUpperCase() + key.slice(1);
		if (setter in msg) {
			msg[setter](data[key]);
		}
	});
	return msg;
}
`

func (g *generator) generateFile(file *descriptor.FileDescriptorProto, forBrowser bool) *plugin.CodeGeneratorResponse_File {
	g.P(`/**`)
	g.P(" * Code generated by protoc-gen-twirp_js ", gen.Version, ", DO NOT EDIT.")
	g.P(" * source: ", file.GetName())
	if forBrowser {
		g.P(" * This is the browser version of this code")
		g.P(" * It has a dependency on `fetch`, so polyfill if your browser does not support it.")
		g.P(" * For Example: https://github.com/github/fetch")
	} else {
		g.P(" * This is the node.js version of this code")
		g.P(" * It has a dependency on `node-fetch` module available from npm")
	}
	g.P(" */")
	g.P(`const pb = require(`, strconv.Quote("./"+baseFileName(file)+".js"), `);`)
	if !forBrowser {
		g.P(`const fetch = require("node-fetch")`)
	}
	g.P()
	serialize := nodeJSSerialize
	deserialize := nodeJSDeserialize
	if forBrowser {
		serialize = browserSerialize
		deserialize = browserDeserialize
	}
	g.P(
		baseClientJSPrefix,
		serialize,
		baseClientJSMidpoint,
		deserialize,
		baseClientJSPenultimate,
		strconv.Quote(gen.Version),
		baseClientJSPostfix,
	)
	g.P()
	for _, service := range file.Service {
		g.generateProtobufClient(file, service)
	}

	resp := new(plugin.CodeGeneratorResponse_File)
	suffix := ".node.js"
	if forBrowser {
		suffix = ".browser.js"
	}
	resp.Name = proto.String(baseFileName(file) + "_twirp" + suffix)
	resp.Content = proto.String(g.output.String())
	g.output.Reset()

	return resp
}

func (g *generator) generateProtobufClient(file *descriptor.FileDescriptorProto, service *descriptor.ServiceDescriptorProto) {
	cName := clientName(service)
	comments, err := g.reg.ServiceComments(file, service)
	g.P(`/**`)
	if err == nil && comments.Leading != "" {
		g.printComments(comments, ` * `)
	} else {
		g.P(` * Creates a new `, cName)
	}
	g.P(` */`)
	g.P(`exports.create`, clientName(service), ` = function(baseurl, useJSON) {`)
	g.P(`    const rpc = newClient(baseurl, `, strconv.Quote(fullServiceName(file, service)), `, useJSON);`)
	g.P(`    return {`)
	// for each method...
	l := len(service.Method)
	for i, method := range service.Method {
		methName := methodName(method)
		jsMethodName := strings.ToLower(methName[0:1]) + methName[1:]
		inputName, outputName := methodTypesNames(method)
		// we need field definitions for each field
		// then we don't have to rely on

		comments, err := g.reg.MethodComments(file, service, method)
		if err == nil && comments.Leading != "" {
			g.P(`        /**`)
			g.printComments(comments, `         * `)
			g.P(`         */`)
		}
		trailingComma := ","
		if i == l-1 {
			trailingComma = ""
		}
		g.P(
			`        `,
			jsMethodName,
			`: data => rpc(`,
			strconv.Quote(methName),
			`, buildMessage(pb.`,
			inputName,
			`, data), pb.`,
			outputName,
			`)`,
			trailingComma,
		)
	}
	g.P(`    }`)
	g.P(`}`)
	g.P()
}

func (g *generator) P(args ...string) {
	for _, v := range args {
		g.output.WriteString(v)
	}
	g.output.WriteByte('\n')
}

func (g *generator) printComments(comments typemap.DefinitionComments, prefix string) {
	text := strings.TrimSuffix(comments.Leading, "\n")
	for _, line := range strings.Split(text, "\n") {
		g.P(prefix, strings.TrimPrefix(line, " "))
	}
}

func serviceName(service *descriptor.ServiceDescriptorProto) string {
	return stringutils.CamelCase(service.GetName())
}

func clientName(service *descriptor.ServiceDescriptorProto) string {
	return serviceName(service) + "Client"
}

func fullServiceName(file *descriptor.FileDescriptorProto, service *descriptor.ServiceDescriptorProto) string {
	name := serviceName(service)
	if pkg := file.GetPackage(); pkg != "" {
		name = pkg + "." + name
	}
	return name
}

// lowerCamelCase
func methodName(method *descriptor.MethodDescriptorProto) string {
	return stringutils.CamelCase(method.GetName())
}

func methodTypesNames(meth *descriptor.MethodDescriptorProto) (string, string) {
	in := strings.Split(meth.GetInputType(), ".")
	out := strings.Split(meth.GetOutputType(), ".")
	return in[len(in)-1], out[len(out)-1]
}

func baseFileName(f *descriptor.FileDescriptorProto) string {
	name := *f.Name
	if ext := path.Ext(name); ext == ".proto" || ext == ".protodevel" {
		name = name[:len(name)-len(ext)]
	}
	return name + "_pb"
}
